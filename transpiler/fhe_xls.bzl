# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Common routines for working with XLS in bazel files."""

load(
    "//transpiler:fhe_common.bzl",
    "executable_attr",
    "run_with_stem",
)

_GET_TOP_FUNC_FROM_PROTO = "@com_google_xls//xls/contrib/xlscc:get_top_func_from_proto"
_STRUCT_HEADER_GENERATOR = "//transpiler/struct_transpiler:struct_transpiler"
_XLSCC = "@com_google_xls//xls/contrib/xlscc:xlscc"
_XLS_BOOLEANIFY = "@com_google_xls//xls/tools:booleanify_main"
_XLS_CODEGEN = "@com_google_xls//xls/tools:codegen_main"
_XLS_OPT = "@com_google_xls//xls/tools:opt_main"

XlsCcOutputInfo = provider(
    """The output of compiling C++ using XLScc.""",
    fields = {
        "ir": "XLS IR file generated by XLScc compiler",
        "metadata": "XLS IR protobuf by XLScc compiler",
        "metadata_entry": "Text file containing the entry point for the program",
        "generic_struct_header": "Templates for generic encodings of C++ structs in the source headers. May be None",
        "library_name": "Library name; if empty, stem is used to derive names.",
        "stem": "Name stem derived from input source C++ file (e.g., 'myfile' from 'myfile.cc'.)",
        "hdrs": "Input C++ headers",
    },
)

BooleanifiedIrOutputInfo = provider(
    """The output of booleanifying XLS IR emitted by XLScc.""",
    fields = {
        "ir": "XLS IR file generated by XLScc compiler",
        "metadata": "XLS IR protobuf by XLScc compiler",
        "generic_struct_header": "Templates for generic encodings of C++ structs in the source headers. May be None",
        "hdrs": "Input C++ headers",
    },
)

BooleanifiedIrInfo = provider(
    """Non-file attributes passed forward from XlsCcOutputInfo.""",
    fields = {
        "library_name": "Library name; if empty, stem is used to derive names.",
        "stem": "Name stem derived from input source C++ file (e.g., 'myfile' from 'myfile.cc'.)",
        "optimizer": "Optimizer used to generate the IR",
    },
)

VerilogOutputInfo = provider(
    """Files generated by the conversion of XLS IR to Verilog, as well as file
       attributes passed along from other providers.""",
    fields = {
        "verilog_ir_file": "Optimizer used to generate the IR",
        "metadata": "XLS IR protobuf by XLScc compiler",
        "metadata_entry": "Text file containing the entry point for the program",
        "generic_struct_header": "Templates for generic encodings of C++ structs in the source headers",
        "hdrs": "Input C++ headers",
    },
)

VerilogInfo = provider(
    """Non-file attributes passed along from other providers.""",
    fields = {
        "library_name": "Library name; if empty, stem is used to derive names.",
        "stem": "Name stem derived from input source C++ file (e.g., 'myfile' from 'myfile.cc'.)",
    },
)

def _get_top_func(ctx, library_name, metadata_file):
    """Extract the name of the entry function from the XLS metadata file."""
    return run_with_stem(
        ctx,
        library_name,
        [metadata_file],
        ".entry",
        ctx.executable._get_top_func_from_proto,
        [metadata_file.path],
    )

def _get_cc_to_xls_ir_library_name(ctx):
    """Derive a stem from a file name (e.g., myfile.cc -- myfile)."""
    (library_name, _, _) = ctx.attr.src.label.name.rpartition(".cc")
    return library_name

def _build_xls_ir(ctx, library_name):
    """Build the XLS IR from a C++ source.

    Args:
      ctx: The Blaze context.
      library_name: The stem for the output file.

    Returns:
      A File containing the generated IR and one containing metadata about
      the translated function (signature, etc.).
    """
    ir_file = ctx.actions.declare_file("%s.ir" % library_name)
    metadata_file = ctx.actions.declare_file("%s_meta.proto" % library_name)
    ctx.actions.run_shell(
        inputs = [ctx.file.src] + ctx.files.hdrs,
        outputs = [ir_file, metadata_file],
        tools = [ctx.executable._xlscc],
        command = "%s %s -meta_out %s > %s" % (
            ctx.executable._xlscc.path,
            ctx.file.src.path,
            metadata_file.path,
            ir_file.path,
        ),
    )
    return (ir_file, metadata_file, _get_top_func(ctx, library_name, metadata_file))

def _generate_generic_struct_header(ctx, library_name, metadata, unwrap = []):
    """Transpile XLS C++ structs/classes into generic FHE base classes."""
    generic_struct_h = ctx.actions.declare_file("%s.generic.types.h" % library_name)

    args = [
        "-metadata_path",
        metadata.path,
        "-original_headers",
        ",".join([hdr.path for hdr in ctx.files.hdrs]),
        "-output_path",
        generic_struct_h.path,
    ]
    if len(unwrap):
        args += [
            "-unwrap",
            ",".join(unwrap),
        ]

    ctx.actions.run(
        inputs = [metadata],
        outputs = [generic_struct_h],
        executable = ctx.executable.struct_header_generator,
        arguments = args,
    )

    return generic_struct_h

def _cc_to_xls_ir_impl(ctx):
    stem = _get_cc_to_xls_ir_library_name(ctx)
    library_name = ctx.attr.library_name or stem
    ir_file, metadata_file, metadata_entry_file = _build_xls_ir(ctx, library_name)

    outputs = [
        ir_file,
        metadata_file,
        metadata_entry_file,
    ]
    generic_struct_headers_depset = []

    if ctx.attr.struct_header_generator:
        # TODO: split struct generation into its own rule and invoke
        # after cc_to_xls_ir. The reason being that while this rule is useful
        # for C++ targets, if the target language is not C++ then generating
        # struct headers doesn't make sense.
        generic_struct_h = _generate_generic_struct_header(ctx, library_name, metadata_file, ctx.attr.unwrap)
        generic_struct_headers_depset = depset([generic_struct_h])
        outputs.append(generic_struct_h)

    return [
        DefaultInfo(files = depset(outputs)),
        XlsCcOutputInfo(
            ir = depset([ir_file]),
            metadata = depset([metadata_file]),
            metadata_entry = depset([metadata_entry_file]),
            generic_struct_header = generic_struct_headers_depset,
            library_name = library_name,
            stem = stem,
            hdrs = ctx.attr.hdrs,
        ),
    ]

cc_to_xls_ir = rule(
    doc = """
      This rule uses XLScc to tanspile C++ code to XLS IR.  It emits the IR
      file, the protobuf-metadata file, a file containing the entry point.  It
      also transpiles C++ structs/classes to generic FHE encodings.
      """,
    implementation = _cc_to_xls_ir_impl,
    attrs = {
        "src": attr.label(
            doc = "A single C++ source file to transpile.",
            allow_single_file = [".cc"],
        ),
        "hdrs": attr.label_list(
            doc = "Any headers necessary for conversion to XLS IR.",
            allow_files = [".h"],
        ),
        "library_name": attr.string(
            doc = """
            The name used for the output files (<library_name>.cc and <library_name>.h);
            If not specified, the default is derived from the basename of the source file.
            """,
        ),
        "unwrap": attr.string_list(
            doc = """
            A list of struct names to unwrap.  To unwrap a struct is defined
            only for structs that contain a single field.  When unwrapping a
            struct, its type is replaced by the type of its field.
            """,
        ),
        "struct_header_generator": executable_attr(_STRUCT_HEADER_GENERATOR),
        "_xlscc": executable_attr(_XLSCC),
        "_get_top_func_from_proto": attr.label(
            default = Label(_GET_TOP_FUNC_FROM_PROTO),
            executable = True,
            cfg = "exec",
        ),
    },
)

def _pick_last_bool_file(optimized_files):
    """Pick the last booleanifed IR file from a list of file produced by _optimize_and_booleanify_repeatedly().

    The last %.*.bool.ir file may or may not be the smallest one.  For some IR
    inputs, an additional optimization/booleanification pass results in a
    larger file.  This is why we have num_opt_passes.
    """

    # structure is [%.opt.ir, %.opt.bool.ir, %.opt.bool.opt.ir,
    # %.opt.bool.opt.bool.ir, ...], so every other file is the result of an
    # optimization + booleanification pass.
    return optimized_files[-1]

def optimize_ir(ctx, stem, src, extension, entry, options = []):
    """Optimize XLS IR."""
    return run_with_stem(ctx, stem, [src, entry], extension, ctx.executable._xls_opt, [src.path] + options, entry)

def _booleanify_ir(ctx, stem, src, extension, entry):
    """Booleanify XLS IR."""
    return run_with_stem(ctx, stem, [src, entry], extension, ctx.executable._xls_booleanify, ["--ir_path", src.path], entry)

def _optimize_and_booleanify_repeatedly(ctx, stem, ir_file, entry):
    """Runs several passes of optimization followed by booleanification.

    Returns [%.opt.ir, %.opt.bool.ir, %.opt.bool.opt.ir, %.opt.bool.opt.bool.ir, ...]
    """
    results = [ir_file]
    suffix = ""

    # With zero optimization passes, we still want to run the optimizer with an
    # inlining pass, as the booleanifier expects a single function.
    if ctx.attr.num_opt_passes == 0:
        suffix += ".opt"
        results.append(optimize_ir(ctx, stem, results[-1], suffix + ".ir", entry, ["--run_only_passes=inlining"]))
        suffix += ".bool"
        results.append(_booleanify_ir(ctx, stem, results[-1], suffix + ".ir", entry))
    else:
        for _ in range(ctx.attr.num_opt_passes):
            suffix += ".opt"
            results.append(optimize_ir(ctx, stem, results[-1], suffix + ".ir", entry))
            suffix += ".bool"
            results.append(_booleanify_ir(ctx, stem, results[-1], suffix + ".ir", entry))
    return results[1:]

def _xls_ir_to_bool_ir_impl(ctx):
    src = ctx.attr.src
    ir_input = src[XlsCcOutputInfo].ir.to_list()[0]
    metadata_file = src[XlsCcOutputInfo].metadata.to_list()[0]
    metadata_entry_file = src[XlsCcOutputInfo].metadata_entry.to_list()[0]
    library_name = src[XlsCcOutputInfo].library_name
    stem = src[XlsCcOutputInfo].stem

    generic_struct_header_depset = []
    if src[XlsCcOutputInfo].generic_struct_header:
        generic_struct_header_depset = depset([src[XlsCcOutputInfo].generic_struct_header.to_list()[0]])

    optimized_files = _optimize_and_booleanify_repeatedly(ctx, library_name, ir_input, metadata_entry_file)
    ir_output = _pick_last_bool_file(optimized_files)

    return [
        DefaultInfo(files = depset(optimized_files + [ir_output] + src[DefaultInfo].files.to_list())),
        BooleanifiedIrOutputInfo(
            ir = depset([ir_output]),
            metadata = depset([metadata_file]),
            generic_struct_header = generic_struct_header_depset,
            hdrs = depset(src[XlsCcOutputInfo].hdrs),
        ),
        BooleanifiedIrInfo(
            library_name = library_name,
            stem = stem,
            optimizer = "xls",
        ),
    ]

xls_ir_to_bool_ir = rule(
    doc = """
      This rule takes XLS IR output by XLScc and goes through zero or more
      phases of booleanification and optimization.  The output is an optimized
      booleanified XLS IR file.
      """,
    implementation = _xls_ir_to_bool_ir_impl,
    attrs = {
        "src": attr.label(
            providers = [XlsCcOutputInfo],
            doc = "A single XLS IR source file (emitted by XLScc).",
            mandatory = True,
        ),
        "num_opt_passes": attr.int(
            doc = """
            The number of optimization passes to run on XLS IR (default 1).
            Values <= 0 will skip optimization altogether.
            """,
            default = 1,
        ),
        "_xls_booleanify": executable_attr(_XLS_BOOLEANIFY),
        "_xls_opt": executable_attr(_XLS_OPT),
    },
)

def _generate_verilog(ctx, stem, src, extension, entry):
    """Convert optimized XLS IR to Verilog."""
    return run_with_stem(
        ctx,
        stem,
        [src, entry],
        extension,
        ctx.executable._xls_codegen,
        [
            src.path,
            "--delay_model=unit",
            "--clock_period_ps=1000",
            "--generator=combinational",
            "--use_system_verilog=false",  # edit the YS script if this changes
        ],
        entry,
    )

def _xls_ir_to_verilog_impl(ctx):
    src = ctx.attr.src
    ir_input = src[XlsCcOutputInfo].ir.to_list()[0]
    metadata_file = src[XlsCcOutputInfo].metadata.to_list()[0]
    metadata_entry_file = src[XlsCcOutputInfo].metadata_entry.to_list()[0]
    generic_struct_header = src[XlsCcOutputInfo].generic_struct_header.to_list()[0]
    library_name = src[XlsCcOutputInfo].library_name
    stem = src[XlsCcOutputInfo].stem

    optimized_ir_file = optimize_ir(ctx, library_name, ir_input, ".opt.ir", metadata_entry_file)
    verilog_ir_file = _generate_verilog(ctx, library_name, optimized_ir_file, ".v", metadata_entry_file)

    return [
        DefaultInfo(files = depset([optimized_ir_file, verilog_ir_file] + src[DefaultInfo].files.to_list())),
        VerilogOutputInfo(
            verilog_ir_file = depset([verilog_ir_file]),
            metadata = depset([metadata_file]),
            metadata_entry = depset([metadata_entry_file]),
            generic_struct_header = depset([generic_struct_header]),
            hdrs = depset(src[XlsCcOutputInfo].hdrs),
        ),
        VerilogInfo(
            library_name = library_name,
            stem = stem,
        ),
    ]

xls_ir_to_verilog = rule(
    doc = """
      This rule takes XLS IR output by XLScc and emits synthesizeable
      combinational Verilog."
      """,
    implementation = _xls_ir_to_verilog_impl,
    attrs = {
        "src": attr.label(
            providers = [XlsCcOutputInfo],
            doc = "A single XLS IR source file (emitted by XLScc).",
            mandatory = True,
        ),
        "_xls_opt": executable_attr(_XLS_OPT),
        "_xls_codegen": executable_attr(_XLS_CODEGEN),
    },
)
